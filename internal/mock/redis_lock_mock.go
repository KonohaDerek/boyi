// Code generated by MockGen. DO NOT EDIT.
// Source: ./vendor/github.com/bsm/redislock/redislock.go

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	reflect "reflect"
	time "time"

	gomock "github.com/golang/mock/gomock"
	redis "github.com/redis/go-redis/v9"
)

// MockRedisClient is a mock of RedisClient interface.
type MockRedisClient struct {
	ctrl     *gomock.Controller
	recorder *MockRedisClientMockRecorder
}

// EvalRO implements redislock.RedisClient.
func (*MockRedisClient) EvalRO(ctx context.Context, script string, keys []string, args ...interface{}) *redis.Cmd {
	panic("unimplemented")
}

// EvalShaRO implements redislock.RedisClient.
func (*MockRedisClient) EvalShaRO(ctx context.Context, sha1 string, keys []string, args ...interface{}) *redis.Cmd {
	panic("unimplemented")
}

// MockRedisClientMockRecorder is the mock recorder for MockRedisClient.
type MockRedisClientMockRecorder struct {
	mock *MockRedisClient
}

// NewMockRedisClient creates a new mock instance.
func NewMockRedisClient(ctrl *gomock.Controller) *MockRedisClient {
	mock := &MockRedisClient{ctrl: ctrl}
	mock.recorder = &MockRedisClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRedisClient) EXPECT() *MockRedisClientMockRecorder {
	return m.recorder
}

// Eval mocks base method.
func (m *MockRedisClient) Eval(ctx context.Context, script string, keys []string, args ...interface{}) *redis.Cmd {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, script, keys}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Eval", varargs...)
	ret0, _ := ret[0].(*redis.Cmd)
	return ret0
}

// Eval indicates an expected call of Eval.
func (mr *MockRedisClientMockRecorder) Eval(ctx, script, keys interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, script, keys}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Eval", reflect.TypeOf((*MockRedisClient)(nil).Eval), varargs...)
}

// EvalSha mocks base method.
func (m *MockRedisClient) EvalSha(ctx context.Context, sha1 string, keys []string, args ...interface{}) *redis.Cmd {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, sha1, keys}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "EvalSha", varargs...)
	ret0, _ := ret[0].(*redis.Cmd)
	return ret0
}

// EvalSha indicates an expected call of EvalSha.
func (mr *MockRedisClientMockRecorder) EvalSha(ctx, sha1, keys interface{}, args ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, sha1, keys}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EvalSha", reflect.TypeOf((*MockRedisClient)(nil).EvalSha), varargs...)
}

// ScriptExists mocks base method.
func (m *MockRedisClient) ScriptExists(ctx context.Context, scripts ...string) *redis.BoolSliceCmd {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx}
	for _, a := range scripts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ScriptExists", varargs...)
	ret0, _ := ret[0].(*redis.BoolSliceCmd)
	return ret0
}

// ScriptExists indicates an expected call of ScriptExists.
func (mr *MockRedisClientMockRecorder) ScriptExists(ctx interface{}, scripts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx}, scripts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScriptExists", reflect.TypeOf((*MockRedisClient)(nil).ScriptExists), varargs...)
}

// ScriptLoad mocks base method.
func (m *MockRedisClient) ScriptLoad(ctx context.Context, script string) *redis.StringCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ScriptLoad", ctx, script)
	ret0, _ := ret[0].(*redis.StringCmd)
	return ret0
}

// ScriptLoad indicates an expected call of ScriptLoad.
func (mr *MockRedisClientMockRecorder) ScriptLoad(ctx, script interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ScriptLoad", reflect.TypeOf((*MockRedisClient)(nil).ScriptLoad), ctx, script)
}

// SetNX mocks base method.
func (m *MockRedisClient) SetNX(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.BoolCmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetNX", ctx, key, value, expiration)
	ret0, _ := ret[0].(*redis.BoolCmd)
	return ret0
}

// SetNX indicates an expected call of SetNX.
func (mr *MockRedisClientMockRecorder) SetNX(ctx, key, value, expiration interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetNX", reflect.TypeOf((*MockRedisClient)(nil).SetNX), ctx, key, value, expiration)
}

// MockRetryStrategy is a mock of RetryStrategy interface.
type MockRetryStrategy struct {
	ctrl     *gomock.Controller
	recorder *MockRetryStrategyMockRecorder
}

// MockRetryStrategyMockRecorder is the mock recorder for MockRetryStrategy.
type MockRetryStrategyMockRecorder struct {
	mock *MockRetryStrategy
}

// NewMockRetryStrategy creates a new mock instance.
func NewMockRetryStrategy(ctrl *gomock.Controller) *MockRetryStrategy {
	mock := &MockRetryStrategy{ctrl: ctrl}
	mock.recorder = &MockRetryStrategyMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRetryStrategy) EXPECT() *MockRetryStrategyMockRecorder {
	return m.recorder
}

// NextBackoff mocks base method.
func (m *MockRetryStrategy) NextBackoff() time.Duration {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NextBackoff")
	ret0, _ := ret[0].(time.Duration)
	return ret0
}

// NextBackoff indicates an expected call of NextBackoff.
func (mr *MockRetryStrategyMockRecorder) NextBackoff() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NextBackoff", reflect.TypeOf((*MockRetryStrategy)(nil).NextBackoff))
}
